# API Design Patterns Configuration
# This file defines the patterns and conventions for all APIs in this project.
# Used by: validation scripts, template generators, and AI agents.

version: "1.0"

# =============================================================================
# Pattern Applicability
# =============================================================================
# This project uses a contract-driven architecture with two API types:
#
# REST APIs: CRUD operations on domain resources
#   - Example: GET /tasks/{id}, POST /intake/applications
#   - Defined by: OpenAPI specs
#
# RPC APIs: Behavioral operations that trigger state transitions
#   - Example: POST /tasks/{id}/claim
#   - Generated from: state machine triggers in contract artifacts
#
# See docs/architecture/contract-driven-architecture.md for details.

# =============================================================================
# Naming Conventions
# =============================================================================
naming:
  # URL path segments: kebab-case (lowercase with hyphens)
  # REST example: /user-profiles, /order-items
  # RPC example: /tasks/{id}/claim
  paths: kebab-case

  # Path parameters: camelCase inside braces
  # Example: /users/{userId}, /orders/{orderId}
  path_parameters: camelCase

  # Query parameters: camelCase
  # Example: ?pageSize=10, ?sortOrder=desc
  query_parameters: camelCase

  # Operation IDs: camelCase verb + noun
  # REST example: listPersons, createApplication, getHouseholdById
  # RPC example: claimTask, completeTask, submitApplication
  operation_ids: camelCase

  # Schema/component names: PascalCase
  # Example: Person, ApplicationCreate, HouseholdList
  schemas: PascalCase

  # File names: kebab-case
  # Example: user-profiles.yaml, common-parameters.yaml
  files: kebab-case

# =============================================================================
# List Endpoint Pattern# =============================================================================
list_endpoints:
  # All REST list endpoints (GET /resources) must include these parameters
  required_parameters:
    - ref: "./components/common-parameters.yaml#/SearchQueryParam"
      name: q
      description: Search query using field:value syntax
    - ref: "./components/common-parameters.yaml#/LimitParam"
      name: limit
      description: Maximum items to return (1-100, default 25)
    - ref: "./components/common-parameters.yaml#/OffsetParam"
      name: offset
      description: Number of items to skip (default 0)

  # Response schema must include these properties
  response:
    required_properties:
      - name: items
        type: array
        description: Array of resources
      - name: total
        type: integer
        description: Total number of matching resources
      - name: limit
        type: integer
        description: Requested limit value
      - name: offset
        type: integer
        description: Requested offset value
    recommended_properties:
      - name: hasNext
        type: boolean
        description: Whether more results exist beyond current page

  # Response schema naming: {Resource}List
  # Example: PersonList, ApplicationList
  response_schema_suffix: List

# =============================================================================
# Search Query Syntax# =============================================================================
search_syntax:
  parameter_name: q
  description: |
    Search query using field:value syntax. Multiple conditions separated by
    spaces are ANDed together.

  operators:
    - pattern: "term"
      description: Full-text search across all searchable fields
      example: "john"
    - pattern: "field:value"
      description: Exact match on field
      example: "status:approved"
    - pattern: "field:>value"
      description: Greater than
      example: "income:>1000"
    - pattern: "field:>=value"
      description: Greater than or equal
      example: "income:>=1000"
    - pattern: "field:<value"
      description: Less than
      example: "income:<5000"
    - pattern: "field:<=value"
      description: Less than or equal
      example: "income:<=5000"
    - pattern: "field:val1,val2"
      description: Match any value (OR)
      example: "status:approved,pending"
    - pattern: "-field:value"
      description: Exclude/negate
      example: "-status:denied"
    - pattern: "field:*"
      description: Field exists (not null)
      example: "email:*"
    - pattern: "field.nested:value"
      description: Nested field using dot notation
      example: "address.state:CA"

# =============================================================================
# CRUD Operations# =============================================================================
# =============================================================================
# RPC / State Transition Endpoints
# =============================================================================
# Generated from state machine triggers. Each trigger becomes a POST endpoint
# on the item path: POST /{resources}/{resourceId}/{trigger}
rpc_endpoints:
  path_pattern: "/{resources}/{resourceId}/{trigger}"
  method: POST
  description: |
    RPC endpoints trigger state transitions defined in the state machine
    contract. They are auto-generated by resolve.js from the transitions
    array in the state machine YAML.

  request:
    headers:
      - name: X-Caller-Id
        required: true
        description: Identity of the caller; evaluated by guards that reference $caller.id
    body: Optional. Defined per-trigger in the state machine requestBodies section.

  success_response:
    code: 200
    description: Transition applied successfully
    body: Updated resource with new status

  error_responses:
    400: Missing X-Caller-Id header
    404: Resource not found
    409: |
      Transition not valid from current state, or a guard condition failed.
      Response body includes code: CONFLICT and a descriptive message.
    500: Unexpected server error

  guards:
    description: |
      Guards are preconditions evaluated before a transition is applied.
      Defined in the state machine guards section and referenced by name
      in each transition's guards array.
    context_variables:
      - "$caller.id": Resolved from the X-Caller-Id request header

  validation_exemptions:
    - Pattern validator skips CRUD POST rules (request body, 201, Location header)
    - Detected by isActionPath(): paths with segments after the {id} parameter

# RPC endpoints (POST with action verbs) are generated from state machine triggers.
# REST endpoints follow standard CRUD patterns below.
crud_operations:
  # CREATE - POST /resources
  create:
    method: POST
    path_pattern: "/{resources}"
    success_response:
      code: 201
      description: Resource created successfully
      headers:
        - name: Location
          description: URL of the newly created resource
          format: uri
      body: Created resource object
    error_responses: [400, 422, 500]
    request_body:
      required: true
      schema_suffix: Create
      description: "Payload to create a new {resource}"

  # READ (single) - GET /resources/{id}
  read:
    method: GET
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 200
      description: Resource retrieved successfully
      body: Resource object
    error_responses: [404, 500]

  # READ (list) - GET /resources
  list:
    method: GET
    path_pattern: "/{resources}"
    success_response:
      code: 200
      description: Paginated list of resources
      body: List response with items array
    error_responses: [400, 500]
    parameters: See list_endpoints section

  # UPDATE - PATCH /resources/{id}
  update:
    method: PATCH
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 200
      description: Resource updated successfully
      body: Updated resource object
    error_responses: [400, 404, 422, 500]
    request_body:
      required: true
      schema_suffix: Update
      description: "Partial update payload for {resource}"

  # DELETE - DELETE /resources/{id}
  delete:
    method: DELETE
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 204
      description: Resource deleted successfully
      body: null
    error_responses: [404, 500]

# =============================================================================
# Shared Components# =============================================================================
shared_components:
  # Error responses - use $ref to these
  error_responses:
    400:
      ref: "./components/common-responses.yaml#/BadRequest"
      description: Invalid request parameters or body
    404:
      ref: "./components/common-responses.yaml#/NotFound"
      description: Resource not found
    422:
      ref: "./components/common-responses.yaml#/UnprocessableEntity"
      description: Request body failed validation
    500:
      ref: "./components/common-responses.yaml#/InternalError"
      description: Unexpected server error

  # Query parameters - use $ref to these
  parameters:
    search:
      ref: "./components/common-parameters.yaml#/SearchQueryParam"
    limit:
      ref: "./components/common-parameters.yaml#/LimitParam"
    offset:
      ref: "./components/common-parameters.yaml#/OffsetParam"

  # Reusable schemas - import and reference as needed
  reusable_schemas:
    - ref: "./components/common.yaml#/Address"
      description: Physical mailing address
      fields: [addressLine1, addressLine2, city, stateProvince, postalCode, county]
    - ref: "./components/common.yaml#/Name"
      description: Person's name
      fields: [firstName, middleInitial, middleName, lastName, maidenName]
    - ref: "./components/common.yaml#/PhoneNumber"
      description: Phone number with regex validation
      pattern: '^\+?[0-9 .\-()]{7,20}$'
    - ref: "./components/common.yaml#/Email"
      description: Email address
      format: email
      maxLength: 320

# =============================================================================
# Schema Patterns
# =============================================================================
schema_patterns:
  # Every resource should have these standard fields
  resource_base_fields:
    - name: id
      type: string
      format: uuid
      readOnly: true
      description: Unique identifier (server-generated)
    - name: createdAt
      type: string
      format: date-time
      readOnly: true
      description: Timestamp when resource was created
    - name: updatedAt
      type: string
      format: date-time
      readOnly: true
      description: Timestamp when resource was last updated

  # Common field patterns
  common_fields:
    # Dates
    date_of_birth:
      type: string
      format: date
      example: "1990-05-15"

    # SSN (optional, sensitive)
    social_security_number:
      type: string
      pattern: '^\d{3}-\d{2}-\d{4}$'
      example: "123-45-6789"

    # Money/currency
    monetary_amount:
      type: number
      minimum: 0
      description: Amount in dollars
      example: 1500.00

    # Status enums
    status_pattern:
      type: string
      enum: Define allowed values
      description: Current status of the resource

  # Schema variants for CRUD
  schema_variants:
    base:
      description: Full resource schema with all fields
      suffix: ""
    create:
      description: Schema for POST requests (excludes readOnly fields)
      suffix: Create
    update:
      description: Schema for PATCH requests (all fields optional except id)
      suffix: Update
    list:
      description: Response schema for GET collection endpoints
      suffix: List

  # Foreign key references to other schemas
  foreign_keys:
    description: |
      Foreign key references use the naming convention {entityName}Id with format: uuid.
      This enables automatic relationship detection in tooling like the design reference.
    naming_convention:
      pattern: "{SchemaName}Id"
      format: uuid
      example: "personId references Person, householdId references Household"
    examples:
      - field: personId
        type: string
        format: uuid
        description: Reference to the Person record
        references: Person
      - field: applicationId
        type: string
        format: uuid
        description: Reference to the Application record
        references: Application
    detection:
      - Tooling detects relationships when field ends in 'Id' and has format: uuid
      - The schema name is derived by removing 'Id' suffix and capitalizing
      - Works for both top-level properties and nested array items

# =============================================================================
# File Structure# =============================================================================
# API specs are organized flat with x-extensions for classification.
# See "API Classification" section for x-domain, x-status.
file_structure:
  # Main API specs go in openapi/ root (flat structure)
  api_specs:
    location: "openapi/"
    pattern: "{resource-plural}.yaml"
    organization: |
      APIs are organized logically using x-extensions rather than folders:
      - x-domain: Business domain (intake, client-management, etc.)
      - x-status: Implementation status (planned, stable, deprecated)

      API type (REST vs RPC) is determined by which contract artifacts exist,
      not by a metadata tag. See contract-driven-architecture.md.
    examples:
      - openapi/applications.yaml   # x-domain: intake
      - openapi/persons.yaml        # x-domain: client-management
      - openapi/households.yaml     # x-domain: intake
      - openapi/incomes.yaml        # x-domain: intake
      - openapi/users.yaml          # x-domain: identity-access

  # Shared components in openapi/components/
  components:
    location: "openapi/components/"
    files:
      - common.yaml: Reusable schemas (Address, Name, etc.)
      - common-parameters.yaml: Shared query parameters
      - common-responses.yaml: Shared error responses
      - "{resource}.yaml": Resource-specific schemas

  # Example data in openapi/examples/
  examples:
    location: "openapi/examples/"
    pattern: "{resource-plural}.yaml"
    format: |
      {ResourceName}Example1:
        id: "uuid-here"
        field1: "value1"
        # ... all required fields

  # Generated clients
  generated:
    zodios_clients: "generated/clients/zodios/"
    postman_collection: "generated/postman-collection.json"

# =============================================================================
# API Classification
# =============================================================================
# Extensions for organizing and identifying APIs without folder restructuring.
# These extensions enable filtering, documentation generation, and tooling
# without requiring physical file reorganization.
#
# Note: x-actors and x-capability concepts still apply but belong to contract
# artifacts (state machine YAML), not a separate API metadata layer. See
# docs/architecture/contract-driven-architecture.md.
api_classification:
  description: |
    Instead of organizing APIs into nested folders (which requires tooling changes),
    use OpenAPI extensions to classify APIs by domain, type, and status. This enables:
    - Filtering APIs in documentation
    - Generating domain-specific views
    - Tracking implementation status
    - Future folder reorganization (extensions inform structure)

  extensions:
    x-domain:
      description: The business domain this API belongs to
      type: string
      location: Info level (under info:) or Operation level
      required: true for all API specs
      values:
        # Core domains (from domain-design.md)
        - client-management     # Persistent client identity and relationships
        - intake                # Application submission from client perspective
        - eligibility           # Program-specific interpretation and determination
        - case-management       # Ongoing client relationships and staff assignments
        - workflow              # Tasks, SLAs, verification
        - scheduling            # Appointments and interviews
        - document-management   # Files and uploads
        # Cross-cutting (not domains, but API groupings)
        - identity-access       # Authentication and authorization (Users API)
        - communication         # Notices and correspondence
        - configuration         # Business rules and settings
        - reporting             # Aggregated data and audit events
      example: |
        info:
          title: Applications API
          x-domain: intake

        # Or at operation level for multi-domain specs:
        paths:
          /applications:
            get:
              x-domain: intake

    # x-api-type: Removed. The contract-driven architecture expresses API type
    # through which contract artifacts exist (OpenAPI only = data-shaped/REST,
    # OpenAPI + state machine = behavior-shaped/REST + RPC), not through a
    # metadata tag. Existing specs may still have x-api-type values; these are
    # ignored and will be cleaned up. See design-decisions.md for history.

    x-status:
      description: Implementation/lifecycle status of the API or operation
      type: string
      location: Info level (entire API) or Operation level (specific endpoints)
      default: stable (if not specified)
      values:
        - planned       # Designed but not implemented
        - alpha         # Early implementation, breaking changes expected
        - beta          # Feature complete, stabilizing
        - stable        # Production ready, follows semver
        - deprecated    # Still works but being phased out (use OpenAPI deprecated: true)
      note: |
        For visibility in Swagger UI, also add a description banner:
        > **Status: Planned** - Not yet implemented

        This ensures status is visible regardless of tooling support for x-extensions.
      example: |
        # API-level status
        info:
          title: Workflow API
          x-status: planned
          description: |
            > **Status: Planned** - Not yet implemented

            Task management and workflow orchestration.

        # Operation-level status (for partial implementations)
        paths:
          /tasks:
            get:
              x-status: stable
              summary: List tasks
            post:
              x-status: beta
              summary: Create task
              description: |
                > **Status: Beta** - API may change

                Creates a new task...

    x-visibility:
      description: Who can see/use this API
      type: string
      location: Info level or Operation level
      default: internal
      values:
        - public        # Available to external consumers (clients, partners)
        - partner       # Available to authorized integration partners
        - internal      # Internal use only (staff, system-to-system)
      example: |
        info:
          title: Applications API
          x-visibility: public  # Clients can submit applications

        paths:
          /applications/{id}/internal-notes:
            get:
              x-visibility: internal  # Staff only

  usage_patterns:
    filtering_by_domain: |
      # Find all Intake domain APIs
      grep -l "x-domain: intake" openapi/*.yaml

    documentation_generation: |
      # Generate docs grouped by domain
      for domain in intake workflow case-management; do
        generate-docs --filter "x-domain: $domain" --output "docs/$domain/"
      done

    status_reporting: |
      # List all planned APIs
      grep -l "x-status: planned" openapi/*.yaml

    validation: |
      # Spectral rule to require x-domain
      rules:
        require-x-domain:
          description: All APIs must specify x-domain
          given: "$.info"
          then:
            field: "x-domain"
            function: truthy

  migration_to_folders: |
    If folder-based organization is later desired, x-domain provides the
    classification needed:

    Current:
      openapi/applications.yaml  (x-domain: intake)
      openapi/persons.yaml       (x-domain: client-management)
      openapi/users.yaml         (x-domain: identity-access)

    Future (if reorganized):
      openapi/intake/applications.yaml
      openapi/client-management/persons.yaml
      openapi/identity-access/users.yaml

# =============================================================================
# Validation Rules
# =============================================================================
validation:
  # These are enforced by npm run validate
  layers:
    - name: syntax
      command: "npm run validate:syntax"
      checks:
        - OpenAPI 3.1 compliance
        - All $ref references resolve
        - Examples match schemas
    - name: lint
      command: "npm run validate:lint"
      checks:
        - Naming conventions (paths, operations, schemas)
        - Response codes (POST→201, DELETE→204)
        - Content types (application/json)
    - name: patterns
      command: "npm run validate:patterns"
      checks:
        - List endpoints have search/pagination params
        - List responses have required properties
        - Error responses use shared $refs
        - CRUD operations follow patterns
      exemptions:
        - description: |
            Action/RPC endpoints (POST on paths with segments after the {id}
            parameter, e.g. /pizzas/{pizzaId}/start-preparing) are exempt from
            CRUD POST rules (request body, 201 response, Location header).
            These are generated from state machine triggers and return 200
            with the updated resource.

# =============================================================================
# Error Handling# =============================================================================
# STATUS: Not yet implemented in mock server or validation
error_handling:
  # Standard error response body structure
  response_body:
    required_fields:
      - name: code
        type: string
        description: Machine-readable error code (e.g., "VALIDATION_ERROR", "RESOURCE_NOT_FOUND")
      - name: message
        type: string
        description: Human-readable error description
    optional_fields:
      - name: details
        type: array
        description: Array of specific field-level errors
        items:
          field: Path to the field with error
          code: Field-specific error code
          message: Field-specific error message
      - name: retryable
        type: boolean
        description: Whether the client should retry the request
      - name: retryAfter
        type: integer
        description: Seconds to wait before retry (for rate limiting)

  # Error code taxonomy
  error_codes:
    validation:
      - MISSING_REQUIRED_FIELD
      - INVALID_FORMAT
      - INVALID_VALUE
      - VALUE_OUT_OF_RANGE
      - FIELD_TOO_LONG
    business_rules:
      - DUPLICATE_RESOURCE
      - INVALID_STATE_TRANSITION
      - PREREQUISITE_NOT_MET
      - RESOURCE_LOCKED
      - SLA_CONSTRAINT_VIOLATED
    authorization:
      - UNAUTHORIZED
      - FORBIDDEN
      - INSUFFICIENT_PERMISSIONS
    system:
      - SERVICE_UNAVAILABLE
      - UPSTREAM_TIMEOUT
      - INTERNAL_ERROR

  # HTTP status code guidance
  http_status_guidance:
    400:
      description: Malformed request (can't parse JSON, missing required query params)
      retryable: false
    401:
      description: Authentication required or invalid credentials
      retryable: false
    403:
      description: Authenticated but not authorized for this resource/action
      retryable: false
    404:
      description: Resource not found
      retryable: false
    409:
      description: Conflict (duplicate resource, concurrent modification)
      retryable: true
      note: Client should fetch current state and retry
    422:
      description: Valid JSON but fails business validation
      retryable: false
    429:
      description: Rate limited
      retryable: true
      note: Use retryAfter header
    500:
      description: Unexpected server error
      retryable: true
    503:
      description: Service temporarily unavailable
      retryable: true

# =============================================================================
# API Versioning# =============================================================================
# STATUS: Not yet implemented
versioning:
  strategy: url-path
  description: Version in URL path (e.g., /v1/tasks, /v2/tasks)

  current_version: v1
  supported_versions:
    - v1

  compatibility_rules:
    backward_compatible:
      - Adding new optional request fields
      - Adding new response fields
      - Adding new endpoints
      - Adding new enum values (clients must ignore unknown values)
      - Adding new optional query parameters
    breaking_changes:
      - Removing fields
      - Changing field types
      - Renaming fields
      - Removing enum values
      - Changing URL paths
      - Making optional fields required

  deprecation:
    notice_period_months: 6
    headers:
      - name: Deprecation
        value: "true"
        description: Indicates endpoint is deprecated
      - name: Sunset
        value: "<ISO 8601 date>"
        description: Date when endpoint will be removed
      - name: Link
        value: "<url>; rel=\"successor-version\""
        description: Link to replacement endpoint/documentation

# =============================================================================
# Idempotency
# =============================================================================
# STATUS: Not yet implemented in mock server
# RPC APIs: Required for all POST operations (actions may have side effects)
# REST APIs: Required for POST (create) operations only
idempotency:
  description: |
    Ensures that retrying a request (due to network issues, timeouts, etc.)
    does not cause duplicate side effects. Critical for RPC APIs.

  applies_to:
    rpc_apis: All POST operations (required)
    rest_apis: POST operations that create resources

  mechanism:
    header_name: Idempotency-Key
    format: Client-generated UUID v4
    required: true for applicable operations
    behavior: |
      1. Client generates unique key and includes in request header
      2. Server checks if key has been seen within retention window
      3. If seen: return stored response (do not re-execute)
      4. If new: execute operation, store response with key
    retention_hours: 24
    note: Keys are scoped per client/tenant

  response_headers:
    - name: Idempotent-Replayed
      values: ["true", "false"]
      description: Indicates whether this response is a replay of a previous request

  error_cases:
    - code: IDEMPOTENCY_KEY_REUSED
      status: 422
      description: Same key used with different request body
    - code: IDEMPOTENCY_KEY_MISSING
      status: 400
      description: Required idempotency key not provided

# =============================================================================
# Batch Operations
# =============================================================================
# STATUS: Not yet implemented
# REST APIs: Common for bulk CRUD (e.g., PATCH /tasks/batch)
# RPC APIs: Rare; most RPC operations are single-action. If needed,
#               the process itself handles multiple items (e.g., bulk-reassign).
batch_operations:
  description: |
    For operations that need to affect multiple resources in a single request.
    Useful for bulk updates, imports, and administrative operations.
    Primarily for REST APIs; RPC APIs typically handle batching internally.

  endpoint_pattern: "/{resources}/batch"
  method: POST

  request_body:
    structure:
      operations:
        type: array
        max_items: 100
        items:
          action:
            type: string
            enum: [create, update, delete]
          id:
            type: string
            description: Required for update/delete, omit for create
          data:
            type: object
            description: Resource payload (for create/update)

  response:
    structure:
      total: Total operations requested
      succeeded: Count of successful operations
      failed: Count of failed operations
      results:
        type: array
        items:
          index: Position in request array
          action: The action attempted
          status: '"succeeded" | "failed"'
          id: Resource ID (for successful creates)
          error: Error details (for failures)

  behavior:
    atomicity: false
    description: |
      Batch operations use partial success model - individual operations
      may succeed or fail independently. Client must check results array
      to determine outcome of each operation.
    ordering: Operations processed sequentially in array order
    rate_limiting: Batch counts as N requests toward rate limit

  idempotency:
    description: Batch operations require idempotency key
    scope: Entire batch (not individual operations)

# =============================================================================
# Authentication# =============================================================================
# STATUS: Not yet implemented
# NOTE: States will use their own identity providers. This section defines the
#       interface contract, not the specific provider implementation.
authentication:
  description: |
    How clients prove their identity. The API layer validates tokens but does
    not implement the identity provider - that's state-specific infrastructure.

  # Supported authentication methods (state chooses which to implement)
  supported_methods:
    oauth2_oidc:
      description: OAuth 2.0 with OpenID Connect (recommended for user-facing apps)
      token_type: Bearer
      header: "Authorization: Bearer <token>"
      token_format: JWT (recommended) or opaque
      discovery: "/.well-known/openid-configuration"
      note: State configures their IdP (Okta, Azure AD, Auth0, state-specific)

    api_key:
      description: API keys for server-to-server integration
      header: "X-API-Key: <key>"
      use_cases:
        - Batch jobs
        - Legacy system integration
        - Internal service-to-service
      note: Simpler but less secure; use OAuth for user context

    mtls:
      description: Mutual TLS with client certificates
      use_cases:
        - High-security integrations
        - Federal system connections
      note: Certificate management is state responsibility

  # OpenAPI security scheme definitions (for spec files)
  openapi_security_schemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: OAuth 2.0 Bearer token

    apiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
      description: API key for server-to-server calls

  # Token validation requirements
  token_validation:
    required_claims:
      - sub: Subject (user or service identifier)
      - iat: Issued at timestamp
      - exp: Expiration timestamp
    recommended_claims:
      - iss: Issuer (IdP identifier)
      - aud: Audience (this API)
      - scope: OAuth scopes granted
      - roles: User roles (for RBAC)
      - tenant_id: State/county identifier (if multi-tenant)

  # State configuration guidance
  state_configuration:
    description: |
      Each state configures their identity provider. The API layer needs:
      - JWKS endpoint (for JWT validation)
      - Issuer URL (for token verification)
      - Audience value (this API's identifier)
      - Clock skew tolerance
    environment_variables:
      - AUTH_JWKS_URI: "https://idp.example.gov/.well-known/jwks.json"
      - AUTH_ISSUER: "https://idp.example.gov"
      - AUTH_AUDIENCE: "safety-net-api"
      - AUTH_CLOCK_SKEW_SECONDS: 60

# =============================================================================
# Authorization# =============================================================================
# STATUS: Not yet implemented
# NOTE: Authorization rules may vary by state. This defines the patterns;
#       specific role definitions are state-configurable.
authorization:
  description: |
    What authenticated users can do. Combines role-based access control (RBAC)
    with attribute-based rules (ABAC) for fine-grained permissions.

  # OAuth scopes (coarse-grained API access)
  scopes:
    description: OAuth scopes control broad API access categories
    standard_scopes:
      - name: "applications:read"
        description: Read applications
      - name: "applications:write"
        description: Create/update applications
      - name: "tasks:read"
        description: Read tasks
      - name: "tasks:write"
        description: Update task status, assignments
      - name: "cases:read"
        description: Read case information
      - name: "cases:write"
        description: Update cases
      - name: "config:read"
        description: Read configuration
      - name: "config:admin"
        description: Modify configuration (admin only)
      - name: "audit:read"
        description: Read audit logs

  # Role-based access control
  rbac:
    description: |
      Roles provide bundles of permissions. Roles are state-configurable but
      should follow this general hierarchy.
    standard_roles:
      - name: client
        description: Person applying for/receiving benefits
        typical_scopes: [applications:read, applications:write]
        constraints: Own data only

      - name: authorized_representative
        description: Representative acting on behalf of clients
        typical_scopes: [applications:read, applications:write]
        constraints: Delegated clients only

      - name: caseworker
        description: Staff processing applications and tasks
        typical_scopes: [applications:read, tasks:read, tasks:write, cases:read]
        constraints: Assigned work only

      - name: supervisor
        description: Team lead with approval authority
        typical_scopes: [applications:read, tasks:read, tasks:write, cases:read, cases:write]
        constraints: Team's work, can reassign

      - name: office_manager
        description: Office-level administration
        typical_scopes: [applications:read, tasks:read, cases:read, config:read]
        constraints: Office scope

      - name: program_admin
        description: Program configuration and reporting
        typical_scopes: [config:read, config:admin, audit:read]
        constraints: No case-level PII access

      - name: auditor
        description: Read-only access for compliance review
        typical_scopes: [applications:read, tasks:read, cases:read, audit:read]
        constraints: Read-only, all data

    state_customization: |
      States may define additional roles or modify scope assignments.
      Role names should remain consistent for interoperability.

  # Attribute-based access control
  abac:
    description: |
      Fine-grained rules based on resource and user attributes.
      Evaluated after RBAC role check passes.
    example_rules:
      - rule: "Caseworker can only access assigned cases"
        condition: "resource.assignedToId == user.id"

      - rule: "Supervisor can access team's cases"
        condition: "resource.assignedToId IN user.teamMemberIds"

      - rule: "Office manager can access office's cases"
        condition: "resource.officeId == user.officeId"

      - rule: "Can only view cases for programs user is certified for"
        condition: "resource.programType IN user.certifiedPrograms"

  # Field-level authorization
  field_level:
    description: |
      Some fields require additional authorization beyond endpoint access.
      Same endpoint may return different fields based on role.
    sensitive_fields:
      - field: socialSecurityNumber
        full_access: [auditor, assigned_caseworker_during_verification]
        masked_access: [supervisor, office_manager]  # Last 4 only
        no_access: [client]  # Cannot see own SSN in API response

      - field: internalNotes
        full_access: [caseworker, supervisor]
        no_access: [client, authorized_representative]

    implementation: |
      Use response filtering at the API layer. Do not rely on clients
      to hide fields - the API must not return unauthorized data.

# =============================================================================
# Rate Limiting# =============================================================================
# STATUS: Not yet implemented
rate_limiting:
  description: |
    Protects the API from abuse and ensures fair resource allocation.
    Typically implemented at API gateway level.

  # Standard headers
  headers:
    - name: X-RateLimit-Limit
      description: Maximum requests allowed in window
    - name: X-RateLimit-Remaining
      description: Requests remaining in current window
    - name: X-RateLimit-Reset
      description: Unix timestamp when window resets
    - name: Retry-After
      description: Seconds to wait before retrying (on 429 response)

  # Rate limit tiers (state-configurable)
  default_tiers:
    - tier: standard
      requests_per_minute: 60
      requests_per_hour: 1000
      applies_to: Default for authenticated users

    - tier: elevated
      requests_per_minute: 300
      requests_per_hour: 5000
      applies_to: Trusted internal services

    - tier: batch
      requests_per_minute: 10
      requests_per_hour: 100
      note: Batch endpoints; each batch counts as N requests

  # Response when rate limited
  rate_limit_response:
    status: 429
    body:
      code: RATE_LIMIT_EXCEEDED
      message: Too many requests
      retryAfter: <seconds>

# =============================================================================
# Security Headers# =============================================================================
# STATUS: Not yet implemented
security_headers:
  description: Standard HTTP security headers for all responses

  required_headers:
    - name: Strict-Transport-Security
      value: "max-age=31536000; includeSubDomains"
      description: Enforce HTTPS

    - name: X-Content-Type-Options
      value: "nosniff"
      description: Prevent MIME type sniffing

    - name: X-Frame-Options
      value: "DENY"
      description: Prevent clickjacking

    - name: Cache-Control
      value: "no-store"
      description: Prevent caching of sensitive data
      note: May be relaxed for public/static endpoints

  cors:
    description: Cross-Origin Resource Sharing (state-configurable)
    configuration:
      allowed_origins: State configures allowed frontend domains
      allowed_methods: [GET, POST, PATCH, DELETE, OPTIONS]
      allowed_headers: [Authorization, Content-Type, X-API-Key, Idempotency-Key]
      expose_headers: [X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset]
      max_age: 86400

# =============================================================================
# Audit Logging# =============================================================================
# STATUS: Not yet implemented
audit_logging:
  description: |
    All API access must be logged for compliance and security monitoring.
    Logs must NOT contain PII - use correlation IDs to link to secure storage.

  required_fields:
    - timestamp: ISO 8601 format
    - correlation_id: Request correlation ID
    - user_id: Authenticated user identifier
    - user_role: Role used for this request
    - client_ip: Originating IP address
    - method: HTTP method
    - path: Request path (without query params)
    - resource_type: Type of resource accessed
    - resource_id: ID of resource accessed (if applicable)
    - action: Logical action (create, read, update, delete)
    - status_code: HTTP response status
    - response_time_ms: Request duration

  sensitive_access_logging:
    description: Additional logging for sensitive data access
    triggers:
      - SSN viewed (even read access)
      - PII exported
      - Bulk data access
      - Configuration changes
      - Failed authorization attempts
    additional_fields:
      - fields_accessed: Which sensitive fields were returned
      - business_justification: If provided by user
      - supervisor_notified: For break-glass access

  pii_handling:
    description: Never log PII directly
    guidance:
      - Log resource IDs, not resource content
      - Log field names accessed, not field values
      - Use correlation ID to link to audit detail in secure storage
      - Mask any PII that must appear in logs (e.g., last 4 of SSN)

# =============================================================================
# Correlation IDs# =============================================================================
# STATUS: Not yet implemented
correlation_ids:
  description: |
    Unique identifier that follows a request through all services and logs.
    Essential for distributed tracing and debugging.

  header:
    name: X-Correlation-ID
    format: UUID v4
    behavior: |
      1. If client provides X-Correlation-ID, use it
      2. If not provided, generate a new UUID
      3. Include in all downstream service calls
      4. Include in all log entries
      5. Return in response header

  response_header:
    name: X-Correlation-ID
    description: Echo back the correlation ID used for this request

  logging_integration:
    description: All log entries must include correlationId field
    example: |
      {
        "timestamp": "2024-01-15T10:30:00Z",
        "level": "info",
        "correlationId": "550e8400-e29b-41d4-a716-446655440000",
        "service": "task-api",
        "message": "Task created",
        "taskId": "abc-123"
      }

  propagation:
    description: Pass correlation ID to all downstream calls
    guidance:
      - Include X-Correlation-ID header in HTTP calls to other services
      - Include in message queue message headers
      - Include in async job metadata

# =============================================================================
# ETags and Optimistic Concurrency# =============================================================================
# STATUS: Not yet implemented
etags:
  description: |
    ETags enable optimistic concurrency control (prevent lost updates) and
    conditional requests (caching). REST APIs should support ETags for
    resources that can be updated.

  response_headers:
    ETag:
      description: Opaque identifier for the current resource version
      format: Quoted string (e.g., "abc123" or W/"abc123" for weak)
      generation: Hash of resource content or version number

  request_headers:
    If-Match:
      description: Update only if ETag matches (optimistic locking)
      use_case: Prevent lost updates when multiple users edit same resource
      behavior: |
        1. Client GETs resource, receives ETag
        2. Client PATCHes with If-Match: "etag-value"
        3. If ETag matches current: apply update, return new ETag
        4. If ETag doesn't match: return 412 Precondition Failed

    If-None-Match:
      description: Return resource only if ETag differs (caching)
      use_case: Avoid re-downloading unchanged resources
      behavior: |
        1. Client GETs resource, caches response with ETag
        2. Client GETs again with If-None-Match: "etag-value"
        3. If ETag matches: return 304 Not Modified (no body)
        4. If ETag differs: return 200 with new resource and ETag

  error_responses:
    412:
      code: PRECONDITION_FAILED
      description: If-Match ETag doesn't match current version
      message: Resource has been modified by another request
      guidance: Client should re-fetch and retry or notify user of conflict

    304:
      description: Not Modified - resource unchanged since ETag
      body: Empty (client uses cached version)

  implementation_notes:
    - ETags should be opaque to clients (don't expose version numbers directly)
    - Use strong ETags for byte-for-byte comparison
    - Use weak ETags (W/"...") for semantic equivalence
    - Consider ETag scope: entire resource or specific fields

# =============================================================================
# Sorting# =============================================================================
# STATUS: Not yet implemented
sorting:
  description: |
    Standard query parameter for sorting list endpoint results.
    Sorting is typically used with REST APIs that return collections.

  parameter:
    name: sort
    location: query
    type: string
    description: |
      Comma-separated list of fields to sort by. Prefix with - for descending.
      First field is primary sort, subsequent fields are secondary sorts.

  syntax:
    ascending: "fieldName"
    descending: "-fieldName"
    multiple: "field1,-field2,field3"

  examples:
    - sort=createdAt           # Oldest first
    - sort=-createdAt          # Newest first
    - sort=status,-priority    # By status (asc), then priority (desc)
    - sort=-dueDate,createdAt  # By due date (desc), then created (asc)

  default_behavior:
    description: If no sort specified, use sensible default per resource
    typical_defaults:
      - List endpoints: -createdAt (newest first)
      - Search results: relevance score (if applicable)

  error_handling:
    invalid_field:
      status: 400
      code: INVALID_SORT_FIELD
      message: "Unknown sort field: {field}"
    unsortable_field:
      status: 400
      code: FIELD_NOT_SORTABLE
      message: "Field '{field}' does not support sorting"

  implementation_notes:
    - Document sortable fields in OpenAPI spec
    - Consider index implications for sortable fields
    - Limit number of sort fields (e.g., max 3)

# =============================================================================
# Long-Running Operations
# =============================================================================
# STATUS: Not yet implemented
long_running_operations:
  description: |
    Pattern for operations that take too long for a synchronous response.
    Common in RPC APIs for complex business operations (e.g., batch
    eligibility determination, bulk document processing).

  threshold:
    description: Operations expected to take >30 seconds should be async
    note: Exact threshold depends on client requirements and infrastructure

  pattern:
    name: Polling with Operation Resource
    flow: |
      1. Client POSTs to initiate operation
      2. Server returns 202 Accepted with operation ID and status URL
      3. Client polls status URL until complete
      4. When complete, status includes result or result URL

  initiation:
    request:
      method: POST
      path: "/processes/{domain}/{resource}/{action}"
      body: Operation parameters
      headers:
        Idempotency-Key: Required (operations are idempotent)

    response:
      status: 202 Accepted
      headers:
        Location: URL to poll for status
      body:
        operationId: UUID
        status: '"pending" | "running"'
        statusUrl: "/operations/{operationId}"
        estimatedCompletionTime: ISO 8601 datetime (optional)

  status_polling:
    request:
      method: GET
      path: "/operations/{operationId}"

    response_pending:
      status: 200
      body:
        operationId: UUID
        status: '"pending" | "running"'
        progress: 0-100 (optional)
        message: Human-readable status (optional)

    response_completed:
      status: 200
      body:
        operationId: UUID
        status: "completed"
        completedAt: ISO 8601 datetime
        result: Inline result (if small)
        resultUrl: URL to fetch result (if large)

    response_failed:
      status: 200
      body:
        operationId: UUID
        status: "failed"
        error:
          code: Error code
          message: Error description
        failedAt: ISO 8601 datetime

  cancellation:
    description: Allow clients to cancel long-running operations
    request:
      method: DELETE
      path: "/operations/{operationId}"
    response:
      status: 200 (cancelled) or 409 (cannot cancel - already complete)

  polling_guidance:
    initial_delay: 1 second
    max_delay: 30 seconds
    backoff: Exponential with jitter
    note: Include Retry-After header in status responses

  alternative_patterns:
    webhooks:
      description: Server calls client webhook when complete
      trade_off: More complex but avoids polling overhead
    server_sent_events:
      description: Client maintains connection for real-time updates
      trade_off: More complex, connection management issues

# =============================================================================
# Circuit Breakers# =============================================================================
# STATUS: Not yet implemented
circuit_breakers:
  description: |
    Protect the system when external dependencies fail. Circuit breakers prevent
    cascade failures by failing fast when a dependency is unavailable.

  when_to_use:
    - External verification sources (IRS, SSA, state databases)
    - Vendor system adapters (workflow tools, case management systems)
    - Notice delivery services (email, SMS, postal)
    - Any external API with potential for latency or availability issues

  states:
    closed:
      description: Normal operation - requests pass through
      behavior: Track failure rate
    open:
      description: Dependency is failing - fail fast without calling
      behavior: Return fallback response or error immediately
    half_open:
      description: Testing if dependency has recovered
      behavior: Allow limited requests through to test

  configuration:
    failure_threshold:
      description: Number/percentage of failures before opening circuit
      recommended: 5 failures or 50% error rate in 30 seconds
    reset_timeout:
      description: Time to wait before trying half-open
      recommended: 30 seconds
    half_open_requests:
      description: Number of test requests in half-open state
      recommended: 3 requests
    timeout:
      description: Request timeout before counting as failure
      recommended: 10 seconds for external APIs

  fallback_strategies:
    verification_sources:
      - strategy: Manual fallback
        description: Route to manual verification queue
        example: "If IRS unavailable, create manual verification task"
      - strategy: Cached data
        description: Use last known good data with staleness indicator
        example: "Use cached wage data from previous verification"
      - strategy: Graceful degradation
        description: Continue without this data source
        example: "Skip optional verification, flag for later"

    vendor_adapters:
      - strategy: Queue for retry
        description: Store operation for later replay
        example: "Queue task creation for retry when vendor recovers"
      - strategy: Local fallback
        description: Use local implementation temporarily
        example: "Use mock database until vendor system recovers"

  monitoring:
    metrics:
      - circuit_state: Current state (closed/open/half_open)
      - circuit_failures: Failure count that triggered open
      - circuit_success_rate: Success rate after recovery
    alerts:
      - Circuit opened (dependency down)
      - Circuit stuck open for > 5 minutes
      - High failure rate approaching threshold

  openapi_extension:
    name: x-circuit-breaker
    location: Operation level
    example: |
      paths:
        /processes/workflow/verification/start:
          post:
            x-circuit-breaker:
              enabled: true
              fallback: manual_verification
              timeout_ms: 10000

# =============================================================================
# Data Classification# =============================================================================
# STATUS: Not yet implemented
data_classification:
  description: |
    All API fields should be classified for appropriate handling. Classification
    drives encryption, logging, access control, and retention policies.

  classifications:
    pii:
      description: Personally Identifiable Information - can identify an individual
      handling:
        - Encrypt at rest
        - Mask in logs (show last 4 digits max)
        - Log all access for audit
        - Exclude from search indexes unless necessary
        - Subject to right-to-deletion requests
      retention: Per program requirements, typically 7 years after case closure

    sensitive:
      description: Sensitive data that is not PII but requires protection
      handling:
        - Encrypt at rest
        - Exclude from general logs
        - Restrict access by role
        - May appear in audit logs
      retention: Same as PII

    internal:
      description: Internal operational data
      handling:
        - Standard encryption at rest
        - May appear in logs
        - Standard access controls
      retention: Per operational needs

    public:
      description: Non-sensitive reference data
      handling:
        - Standard encryption at rest
        - May be cached
        - May appear in logs
        - No special access restrictions
      retention: Indefinite for reference data

  pii_fields:
    description: Fields that should be classified as PII
    fields:
      - socialSecurityNumber
      - dateOfBirth
      - firstName
      - lastName
      - middleName
      - maidenName
      - address (all address fields)
      - phoneNumber
      - email
      - driversLicenseNumber
      - passportNumber
      - alienNumber
      - bankAccountNumber
      - routingNumber
      - medicaidId
      - medicareId

  sensitive_fields:
    description: Fields that should be classified as sensitive
    fields:
      - income (all income fields)
      - assets (all asset fields)
      - expenses
      - medicalConditions
      - disabilityStatus
      - immigrationStatus
      - citizenshipStatus
      - criminalHistory
      - drugScreeningResults
      - caseNotes
      - internalNotes

  openapi_extensions:
    x-data-classification:
      description: Classification level for this field
      type: string
      enum: [pii, sensitive, internal, public]
      location: Schema property level
      example: |
        Person:
          properties:
            socialSecurityNumber:
              type: string
              x-data-classification: pii
              x-encrypt: true
            income:
              type: number
              x-data-classification: sensitive

    x-encrypt:
      description: Whether this field must be encrypted at rest
      type: boolean
      default: false (true for pii/sensitive)
      location: Schema property level

    x-mask-in-logs:
      description: How to mask this field in logs
      type: string
      enum: [full, last4, hash, exclude]
      default: exclude for pii, full for sensitive
      location: Schema property level

  implementation_notes:
    - Use schema preprocessing to validate classifications are set
    - Generate data handling documentation from classifications
    - API gateway/middleware can enforce masking based on extensions
    - Audit logging can use classifications to determine detail level
